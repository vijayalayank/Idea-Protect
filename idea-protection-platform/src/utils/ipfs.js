import axios from 'axios'\nimport { PINATA_CONFIG, MAX_FILE_SIZE, ERROR_MESSAGES } from './constants.js'\n\n/**\n * Upload a file to IPFS using Pinata\n * @param {File} file - The file to upload\n * @param {Object} metadata - Optional metadata for the file\n * @returns {Promise<string>} - The IPFS hash of the uploaded file\n */\nexport const uploadFileToIPFS = async (file, metadata = {}) => {\n  if (!file) {\n    throw new Error('No file provided')\n  }\n\n  if (file.size > MAX_FILE_SIZE) {\n    throw new Error(ERROR_MESSAGES.FILE_TOO_LARGE)\n  }\n\n  const formData = new FormData()\n  formData.append('file', file)\n\n  // Add metadata if provided\n  const pinataMetadata = {\n    name: metadata.name || file.name,\n    keyvalues: {\n      originalName: file.name,\n      fileSize: file.size.toString(),\n      uploadedAt: new Date().toISOString(),\n      ...metadata.keyvalues\n    }\n  }\n\n  formData.append('pinataMetadata', JSON.stringify(pinataMetadata))\n\n  // Pin options\n  const pinataOptions = {\n    cidVersion: 1,\n    ...metadata.options\n  }\n\n  formData.append('pinataOptions', JSON.stringify(pinataOptions))\n\n  try {\n    const response = await axios.post(\n      'https://api.pinata.cloud/pinning/pinFileToIPFS',\n      formData,\n      {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n          'Authorization': `Bearer ${PINATA_CONFIG.JWT}`\n        },\n        maxContentLength: MAX_FILE_SIZE,\n        maxBodyLength: MAX_FILE_SIZE\n      }\n    )\n\n    return response.data.IpfsHash\n  } catch (error) {\n    console.error('Error uploading file to IPFS:', error)\n    throw new Error(ERROR_MESSAGES.PINATA_ERROR)\n  }\n}\n\n/**\n * Upload JSON data to IPFS using Pinata\n * @param {Object} data - The data to upload as JSON\n * @param {string} name - The name for the JSON file\n * @returns {Promise<string>} - The IPFS hash of the uploaded data\n */\nexport const uploadJSONToIPFS = async (data, name = 'data.json') => {\n  if (!data) {\n    throw new Error('No data provided')\n  }\n\n  const jsonString = JSON.stringify(data, null, 2)\n  const blob = new Blob([jsonString], { type: 'application/json' })\n  const file = new File([blob], name, { type: 'application/json' })\n\n  return uploadFileToIPFS(file, {\n    name: name,\n    keyvalues: {\n      contentType: 'application/json',\n      dataType: 'metadata'\n    }\n  })\n}\n\n/**\n * Retrieve data from IPFS\n * @param {string} hash - The IPFS hash to retrieve\n * @returns {Promise<any>} - The retrieved data\n */\nexport const retrieveFromIPFS = async (hash) => {\n  if (!hash) {\n    throw new Error('No IPFS hash provided')\n  }\n\n  try {\n    const response = await axios.get(\n      `${PINATA_CONFIG.GATEWAY_URL}${hash}`,\n      {\n        timeout: 30000 // 30 second timeout\n      }\n    )\n\n    return response.data\n  } catch (error) {\n    console.error('Error retrieving from IPFS:', error)\n    throw new Error('Failed to retrieve data from IPFS')\n  }\n}\n\n/**\n * Get file info from IPFS (headers only)\n * @param {string} hash - The IPFS hash\n * @returns {Promise<Object>} - File information\n */\nexport const getFileInfo = async (hash) => {\n  if (!hash) {\n    throw new Error('No IPFS hash provided')\n  }\n\n  try {\n    const response = await axios.head(\n      `${PINATA_CONFIG.GATEWAY_URL}${hash}`\n    )\n\n    return {\n      contentType: response.headers['content-type'],\n      contentLength: response.headers['content-length'],\n      lastModified: response.headers['last-modified']\n    }\n  } catch (error) {\n    console.error('Error getting file info from IPFS:', error)\n    throw new Error('Failed to get file info from IPFS')\n  }\n}\n\n/**\n * Generate a download URL for an IPFS file\n * @param {string} hash - The IPFS hash\n * @param {string} filename - Optional filename for download\n * @returns {string} - The download URL\n */\nexport const getDownloadUrl = (hash, filename = null) => {\n  if (!hash) {\n    throw new Error('No IPFS hash provided')\n  }\n\n  let url = `${PINATA_CONFIG.GATEWAY_URL}${hash}`\n  \n  if (filename) {\n    url += `?filename=${encodeURIComponent(filename)}`\n  }\n\n  return url\n}\n\n/**\n * Pin existing IPFS content (if you have the hash but want to ensure it's pinned)\n * @param {string} hash - The IPFS hash to pin\n * @param {Object} metadata - Optional metadata\n * @returns {Promise<Object>} - Pin response\n */\nexport const pinExistingIPFSContent = async (hash, metadata = {}) => {\n  if (!hash) {\n    throw new Error('No IPFS hash provided')\n  }\n\n  const pinataMetadata = {\n    name: metadata.name || `Pinned content ${hash}`,\n    keyvalues: {\n      pinnedAt: new Date().toISOString(),\n      ...metadata.keyvalues\n    }\n  }\n\n  try {\n    const response = await axios.post(\n      'https://api.pinata.cloud/pinning/pinByHash',\n      {\n        hashToPin: hash,\n        pinataMetadata\n      },\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${PINATA_CONFIG.JWT}`\n        }\n      }\n    )\n\n    return response.data\n  } catch (error) {\n    console.error('Error pinning existing IPFS content:', error)\n    throw new Error('Failed to pin existing IPFS content')\n  }\n}\n\n/**\n * Get list of pinned files from Pinata\n * @param {Object} options - Query options\n * @returns {Promise<Object>} - List of pinned files\n */\nexport const getPinnedFiles = async (options = {}) => {\n  try {\n    const params = {\n      status: 'pinned',\n      pageLimit: options.pageLimit || 10,\n      pageOffset: options.pageOffset || 0,\n      ...options\n    }\n\n    const response = await axios.get(\n      'https://api.pinata.cloud/data/pinList',\n      {\n        headers: {\n          'Authorization': `Bearer ${PINATA_CONFIG.JWT}`\n        },\n        params\n      }\n    )\n\n    return response.data\n  } catch (error) {\n    console.error('Error getting pinned files:', error)\n    throw new Error('Failed to get pinned files')\n  }\n}\n\n/**\n * Validate file before upload\n * @param {File} file - The file to validate\n * @returns {Object} - Validation result\n */\nexport const validateFile = (file) => {\n  const result = {\n    isValid: true,\n    errors: []\n  }\n\n  if (!file) {\n    result.isValid = false\n    result.errors.push('No file provided')\n    return result\n  }\n\n  if (file.size > MAX_FILE_SIZE) {\n    result.isValid = false\n    result.errors.push(ERROR_MESSAGES.FILE_TOO_LARGE)\n  }\n\n  if (file.size === 0) {\n    result.isValid = false\n    result.errors.push('File is empty')\n  }\n\n  return result\n}\n\n/**\n * Format file size for display\n * @param {number} bytes - Size in bytes\n * @returns {string} - Formatted size string\n */\nexport const formatFileSize = (bytes) => {\n  const sizes = ['B', 'KB', 'MB', 'GB']\n  if (bytes === 0) return '0 B'\n  \n  const i = Math.floor(Math.log(bytes) / Math.log(1024))\n  const size = bytes / Math.pow(1024, i)\n  \n  return `${Math.round(size * 100) / 100} ${sizes[i]}`\n}\n\n/**\n * Get file type icon\n * @param {string} type - MIME type\n * @returns {string} - Emoji icon\n */\nexport const getFileTypeIcon = (type) => {\n  if (!type) return 'üìÅ'\n  \n  if (type.includes('pdf')) return 'üìÑ'\n  if (type.includes('image')) return 'üñºÔ∏è'\n  if (type.includes('zip') || type.includes('archive')) return 'üì¶'\n  if (type.includes('spreadsheet') || type.includes('excel')) return 'üìä'\n  if (type.includes('document') || type.includes('word')) return 'üìù'\n  if (type.includes('text')) return 'üìÉ'\n  if (type.includes('video')) return 'üé•'\n  if (type.includes('audio')) return 'üéµ'\n  if (type.includes('code') || type.includes('javascript') || type.includes('json')) return 'üíª'\n  \n  return 'üìÅ'\n}"