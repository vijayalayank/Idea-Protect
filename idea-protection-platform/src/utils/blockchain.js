import { ethers } from 'ethers'\nimport {\n  SEPOLIA_CHAIN_ID,\n  IDEA_PROTECTION_CONTRACT_ADDRESS,\n  GAS_LIMITS,\n  ERROR_MESSAGES,\n  EVENT_SIGNATURES\n} from './constants.js'\n\n// Smart Contract ABI (This will need to be updated with your actual contract ABI)\nconst IDEA_PROTECTION_ABI = [\n  // Events\n  \"event IdeaSubmitted(uint256 indexed ideaId, address indexed creator, string ipfsHash, bool isPublic)\",\n  \"event IdeaUpdated(uint256 indexed ideaId, string newIpfsHash)\",\n  \"event InterestExpressed(uint256 indexed ideaId, address indexed interested)\",\n  \n  // Functions\n  \"function submitIdea(string memory ipfsHash, bool isPublic) external returns (uint256)\",\n  \"function updateIdea(uint256 ideaId, string memory newIpfsHash) external\",\n  \"function expressInterest(uint256 ideaId) external\",\n  \"function getIdea(uint256 ideaId) external view returns (address creator, string memory ipfsHash, bool isPublic, uint256 timestamp, uint256 interestCount)\",\n  \"function getCreatorIdeas(address creator) external view returns (uint256[] memory)\",\n  \"function getPublicIdeas() external view returns (uint256[] memory)\",\n  \"function getTotalIdeas() external view returns (uint256)\",\n  \"function isCreator(uint256 ideaId, address user) external view returns (bool)\",\n  \"function hasExpressedInterest(uint256 ideaId, address user) external view returns (bool)\"\n]\n\n/**\n * Get the smart contract instance\n * @param {ethers.Signer} signer - The signer to use for transactions\n * @returns {ethers.Contract} - The contract instance\n */\nexport const getContract = (signer) => {\n  if (!IDEA_PROTECTION_CONTRACT_ADDRESS || IDEA_PROTECTION_CONTRACT_ADDRESS === '0x0000000000000000000000000000000000000000') {\n    throw new Error('Smart contract not deployed. Please deploy the contract and update the address in constants.js')\n  }\n  \n  return new ethers.Contract(\n    IDEA_PROTECTION_CONTRACT_ADDRESS,\n    IDEA_PROTECTION_ABI,\n    signer\n  )\n}\n\n/**\n * Submit an idea to the blockchain\n * @param {ethers.Signer} signer - The signer for the transaction\n * @param {string} ipfsHash - The IPFS hash of the idea metadata\n * @param {boolean} isPublic - Whether the idea should be public\n * @returns {Promise<Object>} - Transaction result with idea ID\n */\nexport const submitIdea = async (signer, ipfsHash, isPublic = false) => {\n  if (!signer) {\n    throw new Error(ERROR_MESSAGES.WALLET_NOT_CONNECTED)\n  }\n\n  if (!ipfsHash) {\n    throw new Error('IPFS hash is required')\n  }\n\n  try {\n    const contract = getContract(signer)\n    \n    // Estimate gas\n    const gasEstimate = await contract.estimateGas.submitIdea(ipfsHash, isPublic)\n    const gasLimit = gasEstimate.add(gasEstimate.div(10)) // Add 10% buffer\n\n    // Submit transaction\n    const tx = await contract.submitIdea(ipfsHash, isPublic, {\n      gasLimit: gasLimit.gt(GAS_LIMITS.SUBMIT_IDEA) ? gasLimit : GAS_LIMITS.SUBMIT_IDEA\n    })\n\n    console.log('Transaction submitted:', tx.hash)\n    \n    // Wait for confirmation\n    const receipt = await tx.wait()\n    console.log('Transaction confirmed:', receipt)\n\n    // Extract idea ID from event logs\n    const ideaSubmittedEvent = receipt.logs.find(log => {\n      try {\n        const parsed = contract.interface.parseLog(log)\n        return parsed.name === 'IdeaSubmitted'\n      } catch {\n        return false\n      }\n    })\n\n    let ideaId = null\n    if (ideaSubmittedEvent) {\n      const parsed = contract.interface.parseLog(ideaSubmittedEvent)\n      ideaId = parsed.args.ideaId.toString()\n    }\n\n    return {\n      success: true,\n      transactionHash: receipt.transactionHash,\n      blockNumber: receipt.blockNumber,\n      gasUsed: receipt.gasUsed.toString(),\n      ideaId\n    }\n  } catch (error) {\n    console.error('Error submitting idea:', error)\n    \n    if (error.code === 'INSUFFICIENT_FUNDS') {\n      throw new Error(ERROR_MESSAGES.INSUFFICIENT_FUNDS)\n    }\n    \n    if (error.code === 'USER_REJECTED') {\n      throw new Error('Transaction rejected by user')\n    }\n    \n    throw new Error(ERROR_MESSAGES.TRANSACTION_FAILED)\n  }\n}\n\n/**\n * Express interest in an idea\n * @param {ethers.Signer} signer - The signer for the transaction\n * @param {string|number} ideaId - The ID of the idea\n * @returns {Promise<Object>} - Transaction result\n */\nexport const expressInterest = async (signer, ideaId) => {\n  if (!signer) {\n    throw new Error(ERROR_MESSAGES.WALLET_NOT_CONNECTED)\n  }\n\n  if (!ideaId) {\n    throw new Error('Idea ID is required')\n  }\n\n  try {\n    const contract = getContract(signer)\n    \n    // Check if user has already expressed interest\n    const userAddress = await signer.getAddress()\n    const hasInterest = await contract.hasExpressedInterest(ideaId, userAddress)\n    \n    if (hasInterest) {\n      throw new Error('You have already expressed interest in this idea')\n    }\n\n    // Submit transaction\n    const tx = await contract.expressInterest(ideaId, {\n      gasLimit: GAS_LIMITS.EXPRESS_INTEREST\n    })\n\n    console.log('Interest transaction submitted:', tx.hash)\n    \n    const receipt = await tx.wait()\n    console.log('Interest transaction confirmed:', receipt)\n\n    return {\n      success: true,\n      transactionHash: receipt.transactionHash,\n      blockNumber: receipt.blockNumber,\n      gasUsed: receipt.gasUsed.toString()\n    }\n  } catch (error) {\n    console.error('Error expressing interest:', error)\n    \n    if (error.message.includes('already expressed interest')) {\n      throw error\n    }\n    \n    if (error.code === 'USER_REJECTED') {\n      throw new Error('Transaction rejected by user')\n    }\n    \n    throw new Error('Failed to express interest')\n  }\n}\n\n/**\n * Get idea details from blockchain\n * @param {ethers.Provider} provider - The provider to use for reading\n * @param {string|number} ideaId - The ID of the idea\n * @returns {Promise<Object>} - Idea details\n */\nexport const getIdea = async (provider, ideaId) => {\n  if (!provider) {\n    throw new Error('Provider is required')\n  }\n\n  if (!ideaId) {\n    throw new Error('Idea ID is required')\n  }\n\n  try {\n    const contract = new ethers.Contract(\n      IDEA_PROTECTION_CONTRACT_ADDRESS,\n      IDEA_PROTECTION_ABI,\n      provider\n    )\n\n    const ideaData = await contract.getIdea(ideaId)\n    \n    return {\n      creator: ideaData[0],\n      ipfsHash: ideaData[1],\n      isPublic: ideaData[2],\n      timestamp: new Date(ideaData[3].toNumber() * 1000),\n      interestCount: ideaData[4].toNumber()\n    }\n  } catch (error) {\n    console.error('Error getting idea:', error)\n    throw new Error('Failed to retrieve idea from blockchain')\n  }\n}\n\n/**\n * Get all ideas created by a specific address\n * @param {ethers.Provider} provider - The provider to use for reading\n * @param {string} creatorAddress - The creator's address\n * @returns {Promise<Array>} - Array of idea IDs\n */\nexport const getCreatorIdeas = async (provider, creatorAddress) => {\n  if (!provider) {\n    throw new Error('Provider is required')\n  }\n\n  if (!creatorAddress) {\n    throw new Error('Creator address is required')\n  }\n\n  try {\n    const contract = new ethers.Contract(\n      IDEA_PROTECTION_CONTRACT_ADDRESS,\n      IDEA_PROTECTION_ABI,\n      provider\n    )\n\n    const ideaIds = await contract.getCreatorIdeas(creatorAddress)\n    return ideaIds.map(id => id.toString())\n  } catch (error) {\n    console.error('Error getting creator ideas:', error)\n    throw new Error('Failed to retrieve creator ideas from blockchain')\n  }\n}\n\n/**\n * Get all public ideas\n * @param {ethers.Provider} provider - The provider to use for reading\n * @returns {Promise<Array>} - Array of idea IDs\n */\nexport const getPublicIdeas = async (provider) => {\n  if (!provider) {\n    throw new Error('Provider is required')\n  }\n\n  try {\n    const contract = new ethers.Contract(\n      IDEA_PROTECTION_CONTRACT_ADDRESS,\n      IDEA_PROTECTION_ABI,\n      provider\n    )\n\n    const ideaIds = await contract.getPublicIdeas()\n    return ideaIds.map(id => id.toString())\n  } catch (error) {\n    console.error('Error getting public ideas:', error)\n    throw new Error('Failed to retrieve public ideas from blockchain')\n  }\n}\n\n/**\n * Get the total number of ideas submitted\n * @param {ethers.Provider} provider - The provider to use for reading\n * @returns {Promise<number>} - Total number of ideas\n */\nexport const getTotalIdeas = async (provider) => {\n  if (!provider) {\n    throw new Error('Provider is required')\n  }\n\n  try {\n    const contract = new ethers.Contract(\n      IDEA_PROTECTION_CONTRACT_ADDRESS,\n      IDEA_PROTECTION_ABI,\n      provider\n    )\n\n    const total = await contract.getTotalIdeas()\n    return total.toNumber()\n  } catch (error) {\n    console.error('Error getting total ideas:', error)\n    throw new Error('Failed to get total ideas count')\n  }\n}\n\n/**\n * Check if a user is the creator of an idea\n * @param {ethers.Provider} provider - The provider to use for reading\n * @param {string|number} ideaId - The ID of the idea\n * @param {string} userAddress - The user's address\n * @returns {Promise<boolean>} - Whether the user is the creator\n */\nexport const isCreator = async (provider, ideaId, userAddress) => {\n  if (!provider || !ideaId || !userAddress) {\n    return false\n  }\n\n  try {\n    const contract = new ethers.Contract(\n      IDEA_PROTECTION_CONTRACT_ADDRESS,\n      IDEA_PROTECTION_ABI,\n      provider\n    )\n\n    return await contract.isCreator(ideaId, userAddress)\n  } catch (error) {\n    console.error('Error checking if user is creator:', error)\n    return false\n  }\n}\n\n/**\n * Check if a user has expressed interest in an idea\n * @param {ethers.Provider} provider - The provider to use for reading\n * @param {string|number} ideaId - The ID of the idea\n * @param {string} userAddress - The user's address\n * @returns {Promise<boolean>} - Whether the user has expressed interest\n */\nexport const hasExpressedInterest = async (provider, ideaId, userAddress) => {\n  if (!provider || !ideaId || !userAddress) {\n    return false\n  }\n\n  try {\n    const contract = new ethers.Contract(\n      IDEA_PROTECTION_CONTRACT_ADDRESS,\n      IDEA_PROTECTION_ABI,\n      provider\n    )\n\n    return await contract.hasExpressedInterest(ideaId, userAddress)\n  } catch (error) {\n    console.error('Error checking if user has expressed interest:', error)\n    return false\n  }\n}\n\n/**\n * Listen for blockchain events\n * @param {ethers.Provider} provider - The provider to use for listening\n * @param {string} eventName - The name of the event to listen for\n * @param {Function} callback - The callback function to call when event is received\n * @returns {Function} - Function to stop listening\n */\nexport const listenForEvents = (provider, eventName, callback) => {\n  if (!provider) {\n    throw new Error('Provider is required')\n  }\n\n  const contract = new ethers.Contract(\n    IDEA_PROTECTION_CONTRACT_ADDRESS,\n    IDEA_PROTECTION_ABI,\n    provider\n  )\n\n  const eventFilter = contract.filters[eventName]()\n  \n  const listener = (...args) => {\n    const event = args[args.length - 1] // Last argument is always the event object\n    callback(event, ...args.slice(0, -1))\n  }\n\n  contract.on(eventFilter, listener)\n\n  // Return cleanup function\n  return () => {\n    contract.off(eventFilter, listener)\n  }\n}\n\n/**\n * Get past events from the blockchain\n * @param {ethers.Provider} provider - The provider to use for querying\n * @param {string} eventName - The name of the event\n * @param {Object} options - Query options (fromBlock, toBlock, etc.)\n * @returns {Promise<Array>} - Array of events\n */\nexport const getPastEvents = async (provider, eventName, options = {}) => {\n  if (!provider) {\n    throw new Error('Provider is required')\n  }\n\n  try {\n    const contract = new ethers.Contract(\n      IDEA_PROTECTION_CONTRACT_ADDRESS,\n      IDEA_PROTECTION_ABI,\n      provider\n    )\n\n    const filter = contract.filters[eventName]()\n    const events = await contract.queryFilter(\n      filter,\n      options.fromBlock || 0,\n      options.toBlock || 'latest'\n    )\n\n    return events.map(event => ({\n      ...event,\n      args: event.args,\n      blockNumber: event.blockNumber,\n      transactionHash: event.transactionHash,\n      timestamp: event.blockNumber // You might want to fetch actual block timestamp\n    }))\n  } catch (error) {\n    console.error('Error getting past events:', error)\n    throw new Error('Failed to retrieve past events')\n  }\n}\n\n/**\n * Check if the current network is correct\n * @param {ethers.Provider} provider - The provider to check\n * @returns {Promise<boolean>} - Whether the network is correct\n */\nexport const isCorrectNetwork = async (provider) => {\n  if (!provider) {\n    return false\n  }\n\n  try {\n    const network = await provider.getNetwork()\n    const chainId = '0x' + network.chainId.toString(16)\n    return chainId === SEPOLIA_CHAIN_ID\n  } catch (error) {\n    console.error('Error checking network:', error)\n    return false\n  }\n}\n\n/**\n * Format address for display\n * @param {string} address - The address to format\n * @param {number} chars - Number of characters to show at start and end\n * @returns {string} - Formatted address\n */\nexport const formatAddress = (address, chars = 4) => {\n  if (!address) return ''\n  if (address.length <= chars * 2) return address\n  return `${address.slice(0, chars + 2)}...${address.slice(-chars)}`\n}\n\n/**\n * Convert Wei to Ether\n * @param {string|number} wei - Wei amount\n * @returns {string} - Ether amount\n */\nexport const weiToEther = (wei) => {\n  return ethers.utils.formatEther(wei)\n}\n\n/**\n * Convert Ether to Wei\n * @param {string|number} ether - Ether amount\n * @returns {string} - Wei amount\n */\nexport const etherToWei = (ether) => {\n  return ethers.utils.parseEther(ether.toString()).toString()\n}"