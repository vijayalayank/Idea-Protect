// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title IdeaProtection\n * @dev Smart contract for protecting intellectual property ideas using blockchain timestamping\n * @author Idea Protection Platform\n */\ncontract IdeaProtection {\n    struct Idea {\n        address creator;\n        string ipfsHash;\n        bool isPublic;\n        uint256 timestamp;\n        uint256 interestCount;\n        bool exists;\n    }\n\n    // State variables\n    mapping(uint256 => Idea) public ideas;\n    mapping(address => uint256[]) public creatorToIdeas;\n    mapping(uint256 => address[]) public ideaToInterestedUsers;\n    mapping(uint256 => mapping(address => bool)) public hasExpressedInterest;\n    \n    uint256 public totalIdeas;\n    uint256 public totalPublicIdeas;\n    \n    // Events\n    event IdeaSubmitted(\n        uint256 indexed ideaId,\n        address indexed creator,\n        string ipfsHash,\n        bool isPublic,\n        uint256 timestamp\n    );\n    \n    event IdeaUpdated(\n        uint256 indexed ideaId,\n        string newIpfsHash,\n        uint256 timestamp\n    );\n    \n    event InterestExpressed(\n        uint256 indexed ideaId,\n        address indexed interested,\n        uint256 timestamp\n    );\n    \n    event IdeaVisibilityChanged(\n        uint256 indexed ideaId,\n        bool isPublic,\n        uint256 timestamp\n    );\n\n    // Modifiers\n    modifier onlyIdeaCreator(uint256 _ideaId) {\n        require(ideas[_ideaId].exists, \"Idea does not exist\");\n        require(ideas[_ideaId].creator == msg.sender, \"Not the idea creator\");\n        _;\n    }\n    \n    modifier ideaExists(uint256 _ideaId) {\n        require(ideas[_ideaId].exists, \"Idea does not exist\");\n        _;\n    }\n    \n    modifier validIPFSHash(string memory _ipfsHash) {\n        require(bytes(_ipfsHash).length > 0, \"IPFS hash cannot be empty\");\n        _;\n    }\n\n    /**\n     * @dev Submit a new idea to the blockchain\n     * @param _ipfsHash The IPFS hash containing the idea metadata\n     * @param _isPublic Whether the idea should be publicly visible\n     * @return ideaId The unique ID of the submitted idea\n     */\n    function submitIdea(string memory _ipfsHash, bool _isPublic) \n        external \n        validIPFSHash(_ipfsHash) \n        returns (uint256) \n    {\n        uint256 ideaId = totalIdeas;\n        \n        ideas[ideaId] = Idea({\n            creator: msg.sender,\n            ipfsHash: _ipfsHash,\n            isPublic: _isPublic,\n            timestamp: block.timestamp,\n            interestCount: 0,\n            exists: true\n        });\n        \n        creatorToIdeas[msg.sender].push(ideaId);\n        \n        if (_isPublic) {\n            totalPublicIdeas++;\n        }\n        \n        totalIdeas++;\n        \n        emit IdeaSubmitted(ideaId, msg.sender, _ipfsHash, _isPublic, block.timestamp);\n        \n        return ideaId;\n    }\n\n    /**\n     * @dev Update an existing idea's IPFS hash (only by creator)\n     * @param _ideaId The ID of the idea to update\n     * @param _newIpfsHash The new IPFS hash\n     */\n    function updateIdea(uint256 _ideaId, string memory _newIpfsHash) \n        external \n        onlyIdeaCreator(_ideaId) \n        validIPFSHash(_newIpfsHash) \n    {\n        ideas[_ideaId].ipfsHash = _newIpfsHash;\n        \n        emit IdeaUpdated(_ideaId, _newIpfsHash, block.timestamp);\n    }\n\n    /**\n     * @dev Express interest in a public idea\n     * @param _ideaId The ID of the idea\n     */\n    function expressInterest(uint256 _ideaId) \n        external \n        ideaExists(_ideaId) \n    {\n        require(ideas[_ideaId].isPublic, \"Idea is not public\");\n        require(ideas[_ideaId].creator != msg.sender, \"Cannot express interest in your own idea\");\n        require(!hasExpressedInterest[_ideaId][msg.sender], \"Already expressed interest\");\n        \n        ideaToInterestedUsers[_ideaId].push(msg.sender);\n        hasExpressedInterest[_ideaId][msg.sender] = true;\n        ideas[_ideaId].interestCount++;\n        \n        emit InterestExpressed(_ideaId, msg.sender, block.timestamp);\n    }\n\n    /**\n     * @dev Change the visibility of an idea (only by creator)\n     * @param _ideaId The ID of the idea\n     * @param _isPublic The new visibility status\n     */\n    function changeIdeaVisibility(uint256 _ideaId, bool _isPublic) \n        external \n        onlyIdeaCreator(_ideaId) \n    {\n        bool wasPublic = ideas[_ideaId].isPublic;\n        ideas[_ideaId].isPublic = _isPublic;\n        \n        if (wasPublic && !_isPublic) {\n            totalPublicIdeas--;\n        } else if (!wasPublic && _isPublic) {\n            totalPublicIdeas++;\n        }\n        \n        emit IdeaVisibilityChanged(_ideaId, _isPublic, block.timestamp);\n    }\n\n    /**\n     * @dev Get idea details\n     * @param _ideaId The ID of the idea\n     * @return creator The address of the idea creator\n     * @return ipfsHash The IPFS hash containing idea data\n     * @return isPublic Whether the idea is public\n     * @return timestamp When the idea was created\n     * @return interestCount Number of users interested in the idea\n     */\n    function getIdea(uint256 _ideaId) \n        external \n        view \n        ideaExists(_ideaId) \n        returns (\n            address creator,\n            string memory ipfsHash,\n            bool isPublic,\n            uint256 timestamp,\n            uint256 interestCount\n        ) \n    {\n        Idea memory idea = ideas[_ideaId];\n        \n        // Only return IPFS hash if idea is public or caller is the creator\n        string memory returnHash = \"\";\n        if (idea.isPublic || idea.creator == msg.sender) {\n            returnHash = idea.ipfsHash;\n        }\n        \n        return (\n            idea.creator,\n            returnHash,\n            idea.isPublic,\n            idea.timestamp,\n            idea.interestCount\n        );\n    }\n\n    /**\n     * @dev Get all idea IDs created by a specific address\n     * @param _creator The creator's address\n     * @return Array of idea IDs\n     */\n    function getCreatorIdeas(address _creator) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return creatorToIdeas[_creator];\n    }\n\n    /**\n     * @dev Get all public idea IDs\n     * @return Array of public idea IDs\n     */\n    function getPublicIdeas() \n        external \n        view \n        returns (uint256[] memory) \n    {\n        uint256[] memory publicIdeas = new uint256[](totalPublicIdeas);\n        uint256 currentIndex = 0;\n        \n        for (uint256 i = 0; i < totalIdeas; i++) {\n            if (ideas[i].exists && ideas[i].isPublic) {\n                publicIdeas[currentIndex] = i;\n                currentIndex++;\n            }\n        }\n        \n        return publicIdeas;\n    }\n\n    /**\n     * @dev Get paginated public ideas\n     * @param _offset Starting index\n     * @param _limit Number of ideas to return\n     * @return Array of public idea IDs\n     */\n    function getPublicIdeasPaginated(uint256 _offset, uint256 _limit) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        require(_limit > 0 && _limit <= 100, \"Invalid limit\");\n        \n        uint256[] memory allPublicIdeas = this.getPublicIdeas();\n        \n        if (_offset >= allPublicIdeas.length) {\n            return new uint256[](0);\n        }\n        \n        uint256 endIndex = _offset + _limit;\n        if (endIndex > allPublicIdeas.length) {\n            endIndex = allPublicIdeas.length;\n        }\n        \n        uint256[] memory paginatedIdeas = new uint256[](endIndex - _offset);\n        for (uint256 i = 0; i < endIndex - _offset; i++) {\n            paginatedIdeas[i] = allPublicIdeas[_offset + i];\n        }\n        \n        return paginatedIdeas;\n    }\n\n    /**\n     * @dev Get users who expressed interest in an idea\n     * @param _ideaId The ID of the idea\n     * @return Array of addresses who expressed interest\n     */\n    function getInterestedUsers(uint256 _ideaId) \n        external \n        view \n        ideaExists(_ideaId) \n        returns (address[] memory) \n    {\n        // Only creator can see who is interested in their idea\n        require(ideas[_ideaId].creator == msg.sender, \"Not authorized\");\n        return ideaToInterestedUsers[_ideaId];\n    }\n\n    /**\n     * @dev Check if a user is the creator of an idea\n     * @param _ideaId The ID of the idea\n     * @param _user The user address to check\n     * @return Whether the user is the creator\n     */\n    function isCreator(uint256 _ideaId, address _user) \n        external \n        view \n        returns (bool) \n    {\n        return ideas[_ideaId].exists && ideas[_ideaId].creator == _user;\n    }\n\n    /**\n     * @dev Check if a user has expressed interest in an idea\n     * @param _ideaId The ID of the idea\n     * @param _user The user address to check\n     * @return Whether the user has expressed interest\n     */\n    function hasUserExpressedInterest(uint256 _ideaId, address _user) \n        external \n        view \n        returns (bool) \n    {\n        return hasExpressedInterest[_ideaId][_user];\n    }\n\n    /**\n     * @dev Get contract statistics\n     * @return _totalIdeas Total number of ideas submitted\n     * @return _totalPublicIdeas Total number of public ideas\n     * @return _totalCreators Total number of unique creators\n     */\n    function getContractStats() \n        external \n        view \n        returns (\n            uint256 _totalIdeas,\n            uint256 _totalPublicIdeas,\n            uint256 _totalCreators\n        ) \n    {\n        // For total creators, we'd need to track unique addresses separately\n        // This is a simplified version\n        return (totalIdeas, totalPublicIdeas, 0);\n    }\n\n    /**\n     * @dev Check if an idea exists\n     * @param _ideaId The ID to check\n     * @return Whether the idea exists\n     */\n    function ideaExistsCheck(uint256 _ideaId) \n        external \n        view \n        returns (bool) \n    {\n        return ideas[_ideaId].exists;\n    }\n\n    /**\n     * @dev Get the total number of ideas\n     * @return Total number of ideas\n     */\n    function getTotalIdeas() \n        external \n        view \n        returns (uint256) \n    {\n        return totalIdeas;\n    }\n\n    /**\n     * @dev Get the total number of public ideas\n     * @return Total number of public ideas\n     */\n    function getTotalPublicIdeas() \n        external \n        view \n        returns (uint256) \n    {\n        return totalPublicIdeas;\n    }\n}"